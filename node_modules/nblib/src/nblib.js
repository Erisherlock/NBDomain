
var isBrowser = isBrowser || new Function("try {return this===window;}catch(e){ return false;}");
var axios;
const g_isBrowser = isBrowser();

var _default = {
    API:"https://api.nbdomain.com/v1/",
    //minerAPI:"https://merchantapi.taal.com",
    minerAPI:"https://merchantapi.matterpool.io",
    token:"",
    filepayKey:"",
    debug:true
}
let g_config = null;
let g_libLoaded = false;
let log = console.log;
var filepay;
var BitID;
var miner;
var bsv;


let tld_config = {
    test:{
        address:{
            protocol:"1PuMeZswjsAM7DFHMSdmAGfQ8sGvEctiF5",
            admin:"1PuMeZswjsAM7DFHMSdmAGfQ8sGvEctiF5",
            other_admins:[
            ],
            payment:"19fLpT5LpaMGKuLfUVqmNdXkVceq2rbjyn"
        }
    }
}
 export default class NBLib{
    static async init(option){
        g_config = {
            ..._default,
            ...option
        }
        if(g_config.debug==false)log=(msg)=>{};
        try{
            tld_config = await NBLib.getTLDinfo();
            if(option.enable_write){
                await NBLib._loadWriteLibs();
            }
        }catch(e){
            log(e);
            throw "NBLib Init failed:"+e;
        }
    }
    static async getDomain(domain){
        const res = await NBLib.readDomain(domain);
        log("getting domain:"+domain+"\n",res);
        if(res.code==0){
            const inst = new NBLib(domain,res);
            return inst;
        }
        return null;
    }
    static async regDomain(domain){

    }
	constructor(domain,res){
       this.info = res.obj;
       [this.nid,this.tld] = domain.split('.');
       this.config = tld_config[this.tld].address;
       this.lastTXID = res.obj.last_txid;
       //log(this);
	}
    setPrivateKey(privateKey){
        if(!g_config.enable_write){
            throw "to be able to send transactions, Please enable_write when call init(...)";
        }
        this.pKey = privateKey;
        const objKey = bsv.PrivateKey.fromWIF(privateKey);
        const pubKey = bsv.PublicKey.fromPrivateKey(objKey);
        if(pubKey.toHex()!=this.info.owner_key){
            throw "Not the owner of:"+this.nid+"."+this.tld;
        }
        this._nutxo_out =NBLib._genNUTXO(this.info.owner,2)
    }
    async refresh(){
        const res = await NBLib.readDomain(this.nid+"."+this.tld);
        if(res.code == 0 ){
            const privKey = bsv.PrivateKey.fromWIF(this.pKey);
            if(res.obj.owner!=privKey.toAddress().toString()) return {code:-1,message:"not owner"};
            if(res.obj.last_txid!=this.lastTXID){
                this.lastTXID = res.obj.last_txid;
                return {code:0,message:"updated"};
            }
            return {code:0,message:"no change"};
        }else{
            return res;
        }
    }
    async updateKey(kv,bUser=false){
        let cmd = [bUser?"user":"key",JSON.stringify(kv)];
        return await this._sendCommand(cmd);
    }
    async sell(option){
        const {price,buyer,expire} = option;
        let attrib = {price:price,buyer:buyer,expire:expire};
        if(!option.clear_data)
            attrib.clear_data = option.clear_data;
        let cmd = ["sell",JSON.stringify(attrib)];
        return await this._sendCommand(cmd);
    }
    async _sendCommand(cmd){
        if(!this.pKey){
            throw "please setPrivateKey first";
        } 
        const ref = await this.refresh();
        if(ref.code==-1){
            return ref;
        }
        if(ref.code!=0) {
            return ref;
        }
        const ret = await NBLib._baseSendCommand(this.config.protocol,this.nid,this.pKey,cmd,this._nutxo_out,this.lastTXID); //_writeCommand(protocol, nid, privKey,cmd,nutxo,last_txid)
        return ret; 
    }
    
     async writeNOP(){
        const cmd = ["key",JSON.stringify({__nop:"nop"})];
        const ret = await NBLib._baseSendCommand(this.config.protocol,this.nid,this.pKey,cmd,this._nutxo_out,null);
        return ret;
    }
    async updateUser(kv){
        return await this.updateKey(kv,true);
    }
    async readKey(key){
        return await NBLib.readDomain(key+'.'+this.domain);
    }
    async readUser(user){
        return await NBLib.readDomain(key+'@'+this.domain);
    }
    async isOwner(address){
        return this.info.owner==address;
    }
    static _genNUTXO(address,pos){
        return {
            script:NBLib._genNUTXOOutScript(address),pos:pos,value:601
        }
    }
    static _genNUTXOinputScript(tx, index, satoshis, script, key) {
    let bitcoin = bsv;
    const Script = bsv.Script;
    const privKey = new bitcoin.PrivateKey(key);
    const pubKey = privKey.publicKey;
    const sigtype = bitcoin.crypto.Signature.SIGHASH_ALL | bitcoin.crypto.Signature.SIGHASH_FORKID;
    const flags = bitcoin.Script.Interpreter.SCRIPT_VERIFY_MINIMALDATA | bitcoin.Script.Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID | bitcoin.Script.Interpreter.SCRIPT_ENABLE_MAGNETIC_OPCODES | bitcoin.Script.Interpreter.SCRIPT_ENABLE_MONOLITH_OPCODES;
    const signature = bitcoin.Transaction.sighash.sign( tx, privKey, sigtype, index, script, new bitcoin.crypto.BN(satoshis), flags );
    const strSignature = signature.toBuffer();
    let script1 = new bitcoin.Script()
        .add(
            bsv.deps.Buffer.concat([ strSignature, bsv.deps.Buffer.from([ (sigtype || bitcoin.Signature.SIGHASH_ALL) & 0xff, ]),])
        )
        .add(new bsv.PublicKey(pubKey).toBuffer())
        .add(bsv.Opcode.OP_1)
        .add(bsv.Opcode.OP_2);
    return script1.toHex();
    }
    static loadScript(url, callback){

    var script = document.createElement("script")
    script.type = "text/javascript";

    if (script.readyState){  //IE
        script.onreadystatechange = function(){
            if (script.readyState == "loaded" ||
                    script.readyState == "complete"){
                script.onreadystatechange = null;
              if(callback)  
              callback();
            }
        };
    } else {  //Others
        script.onload = function(){
          if(callback) 
            callback();
        };
    }

    script.src = url;
    document.getElementsByTagName("head")[0].appendChild(script);
}
    static async _loadWriteLibs(){
        return new Promise(resolve=>{


        if(g_libLoaded) {
            resolve(true);
            return;
        }

        if(g_isBrowser){
            const self = this;
            this.loadScript("https://unpkg.com/filepay@latest/dist/filepay.min.js",()=>{
                //console.log(window.filepay.bsv);
                filepay = window.filepay;
                bsv = filepay.bsv;
                self.loadScript("https://unpkg.com/bitidentity@1.0.29/bitIdentity.min.js",()=>{
                    BitID = window.BitID;
                    BitID.config({debug:g_config.debug});

                    self.loadScript("https://unpkg.com/minercraft",()=>{
                        miner = new window.Minercraft({
                          //url: "https://merchantapi.matterpool.io",
                          url: g_config.minerAPI,
                          //url: "https://www.ddpurse.com/openapi",
                          headers: {
                            "Content-Type": "application/json"
                          }
                        });
                    resolve(true);
                    return;
                    });

                });
            });
            resolve(false);
            
            
            
        }else {

            filepay = require('filepay');
            if(!filepay){
                throw "please npm i filepay";
            }
            bsv = filepay.bsv;
            BitID = require('bitIdentity');
            if(!BitID){
                throw "please npm i bitidentity";
            }
            const Craft = require("minercraft");
            if(!Craft){
                throw "please npm i minercraft";
            }
            miner = new Craft({
              //url: "https://merchantapi.matterpool.io",
              url: g_config.minerAPI,
              //url: "https://www.ddpurse.com/openapi",
              headers: {
                "Content-Type": "application/json"
              }
            });
            BitID.config({debug:g_config.debug});
            g_libLoaded = true;
            resolve(true);
        }
        
    });
    }
    static _genNUTXOOutScript(to) { //build nUTXO output script
        if (typeof to === "string") {
            to = new bsv.Address(to);
        }
        const Script = bsv.Script;
        const Opcode = bsv.Opcode;
        var s = new Script();
        s.add(Opcode.OP_2DROP)
            .add(Opcode.OP_DUP)
            .add(Opcode.OP_HASH160)
            .add(to.hashBuffer)
            .add(Opcode.OP_EQUALVERIFY)
            .add(Opcode.OP_CHECKSIG);
        s._network = to.network;
        return s;
    }
    static async _baseSendCommand(protocol, nid, privKey,cmd,nutxo,last_txid, more_to=null,broadcast=true){
        if(!g_config.enable_write){
            throw "to be able to send transactions, Please enable_write when call init(...)";
        }
        return new Promise(async resolve=>{
        const config = {
            api_key:g_config.filepayKey,
            
            pay:{
                key:privKey,
                feeb: 0.5,
                to: [ 
                { data:[protocol,nid],value:0},
                { protocol:"bitIdentity", value: { privateKey: privKey } },

                ]
            }
        }   
        config.pay.to[0].data = config.pay.to[0].data.concat(cmd);
        if(nutxo){
            config.pay.to.push({script:nutxo.script,value:nutxo.value});
        }
        if(more_to){
            config.pay.to = config.pay.to.concat(more_to);
        }

        const self = this;
            if(last_txid){
                config.pay.inputs = [
                    {
                        txid: last_txid,
                        value: nutxo.value,
                        script: nutxo.script,
                        outputIndex: nutxo.pos,
                        required: true,
                        unlockingScript: function (tx, index, satoshis, script, key) {
                            return NBLib._genNUTXOinputScript(tx, index, satoshis, script, key);
                        },
                    },
                ];
            }
            BitID.filepayKey = g_config.filepayKey;
            
            const rawtx = await BitID.gentx(config);
            if(rawtx){
                
                if(!broadcast){
                    resolve({code:0,rawtx:rawtx});
                    return;
                }
                let res = await miner.tx.push(rawtx);
                if(res.txid==''){
                    if(res.resultDescription.indexOf('258')!=-1){ //utxo fail
                        log("nUTXO conflict found");
                        resolve({code:101,message:"nUTXO conflict found"});
                    }
                    res.code = 1;
                }else{
                    res.code = 0;
                }
                resolve(res);
            }else{
                resolve({code:100,message:"bitID.gentx error"});
            }
        });

    }
    static isValidAdmin(tld,address){
        const all = tld_config[tld].address;
        if(address==all.admin) return true;
        return all.other_admins.includs(address);
    }
    static async admin_regDomain(domain,admin_privKey,owner_pubKey,pay_txid,ref){
        if(!g_config.enable_write){
            throw "to be able to send transactions, Please enable_write when call init(...)";
        }
        const dom = domain.split('.');
        const config = tld_config[dom[1]].address;
        const address = bsv.PrivateKey.fromWIF(admin_privKey).toAddress().toString();
        if(config.admin!=address)
            return { code:1,message:"Not allowed"}
        const domain_info = await NBLib.readDomain(domain);
        if(domain_info.code==0) return {code:2,message:"already registered"};
        if(domain_info.price==null) return {code:3,message:"Not allowed to register"};

        const cmd = ['register',owner_pubKey];
        if(pay_txid)cmd.push(JSON.stringify({pay_txid:pay_txid}));
        if(ref)cmd.push(ref);
        const addr = bsv.PublicKey.fromHex(owner_pubKey).toAddress().toString();
        const nutxo = NBLib._genNUTXO(addr,2);
        const ret = await NBLib._baseSendCommand(config.protocol,dom[0],admin_privKey,cmd,nutxo,null);
        return ret;
    }
    static async admin_buyDomain(domain,admin_privKey,owner_pubKey,sell_txid,pay_txid){
        if(!g_config.enable_write){
            throw "to be able to send transactions, Please enable_write when call init(...)";
        }
        const dom = domain.split('.');
        const config = tld_config[dom[1]].address;
        const address = bsv.PrivateKey.fromWIF(admin_privKey).toAddress().toString();
        if(config.admin!=address)
            return { code:1,message:"Not allowed"}
        const cmd = ['buy',owner_pubKey,JSON.stringify({sell_txid:sell_txid,pay_txid:pay_txid})];
        const addr = bsv.PublicKey.fromHex(owner_pubKey).toAddress().toString();
        const nutxo = NBLib._genNUTXO(addr,2);
        const ret = await NBLib._baseSendCommand(config.protocol,dom[0],admin_privKey,cmd,nutxo,null);
        return ret;
    }
    static async admin_writeNOP(domain,admin_privKey,owner_pubKey){
        if(!g_config.enable_write){
            throw "to be able to send transactions, Please enable_write when call init(...)";
        }
        const dom = domain.split('.');
        const config = tld_config[dom[1]].address;
        const address = bsv.PrivateKey.fromWIF(admin_privKey).toAddress().toString();
        if(config.admin!=address)
            return { code:1,message:"Not allowed"}
        const cmd = ['nop'];
        const addr = bsv.PublicKey.fromHex(owner_pubKey).toAddress().toString();
        const nutxo = NBLib._genNUTXO(addr,2);
        const ret = await NBLib._baseSendCommand(config.protocol,dom[0],admin_privKey,cmd,nutxo,null);
        return ret;
    }
    static async buyDomain(domain,privKey){
        const res = await NBLib._buildBuyTX(domain,privKey);
        if(res.code==0){
            const ret = await NBLib._InvokeRawCMD(res.rawtx);
            log(ret);
            return ret;
        }
        return res;
    }
    static async registerDomain(domain,privKey){
        const res = await NBLib._buildRegTX(domain,privKey);
        if(res.code==0){
            const ret = await NBLib._InvokeRawCMD(res.rawtx);
            log(ret);
            return ret;
        }
        return res;
    }
    static async _InvokeRawCMD(rawtx){
        if(!g_config.enable_write){
            throw "to be able to send transactions, Please enable_write when call init(...)";
        }
        const url = g_config.API+"raw_cmd";
        const options = {
          method: "POST",
          headers: { 'content-type': 'application/json;charset=UTF-8', 'Authorization': 'Bearer '+g_config.token },
          mode: "cors"
        };
        try{
            let res = await axios.post(url, JSON.stringify({ rawtx: rawtx }),options);
            let json = res.data;
            log("raw cmd result:",json);
            return {code:0,txid:json.tx,message:"success"};
        }catch(e){
            return {code:1,message:e.message};
        }
    }
    static async _buildRegTX(domain,privKey,ref=null){
        if(!g_config.enable_write){
            throw "to be able to send transactions, Please enable_write when call init(...)";
        }
        const dom = domain.split('.');
        const config = tld_config[dom[1]].address;
        try{
            const res = await NBLib.readDomain(domain);
            if(res.code==0){
                return {code:1,message:"Domain is registered"};
            }
            if(!res.price){
                return {code:2,message:"Domain is reserved"};
            }
            const objKey = bsv.PrivateKey.fromWIF(privKey);
            const pubKey = bsv.PublicKey.fromPrivateKey(objKey);
            const cmd = ['register',pubKey.toHex()];
            if(ref)
                cmd = cmd.concat(ref);
            const more_to = [
                {address:config.payment,value:res.price}
            ]
            const ret = await NBLib._baseSendCommand(config.payment,dom[0],privKey,cmd,null,null,more_to,false);
            return ret;

        }catch(e){
            log(e);
            return {code:100,message:e.message};
        }
    }
    static async _buildBuyTX(domain,privKey){
       if(!g_config.enable_write){
            throw "to be able to send transactions, Please enable_write when call init(...)";
        }
        const dom = domain.split('.');
        const config = tld_config[dom[1]].address;
        try{
            const res = await NBLib.readDomain(domain);
            if(res.code!=0){
                return {code:1,message:"Domain is not registered"};
            }
            if(res.obj.sell_info==null){
                return {code:2,message:"Domain is not on sale"};
            }

            const {buyer,price,expire,sell_txid} = res.obj.sell_info;
            const rExpire = new Date(expire);
            if(Date.now()>rExpire){
              return {code:3,message:"Sell Expired"};
            }
            if(buyer!="any"){
                const address = bsv.PrivateKey.fromWIF(privKey).toAddress().toString();
                if(address!=buyer){
                    return {code:4,message:"Incorrect Buyer"};
                }
            }
            const pay1 = price*0.9 ; 
            const pay2 = price*0.1 ;
            const cmd = ['buy',JSON.stringify({sell_txid:sell_txid})];
            const more_to = [
                {address:res.obj.owner,value:pay1},
                {address:config.payment,value:pay2}
            ]
            const ret = await NBLib._baseSendCommand(config.payment,dom[0],privKey,cmd,null,null,more_to,false);
            return ret;

        }catch(e){
            log(e);
            return {code:100,message:e.message};
        }

        
    }
    

    static async _invokeAPI(para){
        const url = g_config.API+para;
        const myInit = {
                method: 'GET',
                headers: { 'content-type': 'application/json;charset=UTF-8', 'Authorization': 'Bearer '+g_config.token },
                mode: 'cors',
                cache: 'default'
            };
            try{
                const res = await axios.get(url,myInit);
                if(res){
                    return res.data;
                }
            }catch(e){
                log(e);
            }
        return null;
    }
    static async getTLDinfo(){
        return await NBLib._invokeAPI("tld");
    }
 static async readDomain (domain,full=false){
 	const para = "?nid="+domain+"&full="+(full?"true":"false");
 	return await NBLib._invokeAPI(para);
 }
 static async domainFromAddress(address){
    return await NBLib._invokeAPI("find_domain?address="+address);
 }

}

if(g_isBrowser==false){
    axios = require('axios');
}else{
    
    NBLib.loadScript("https://unpkg.com/axios/dist/axios.min.js",()=>{
        axios = window.axios;
    });
}

if(g_isBrowser==false)
    module.exports = NBLib;